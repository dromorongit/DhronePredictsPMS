{"version":3,"names":["_helperPluginUtils","require","_helperCreateClassFeaturesPlugin","generateUid","scope","denyList","name","uid","i","has","mapLast","arr","fn","length","slice","_default","exports","default","declare","types","t","template","traverse","assertVersion","rawNamedEvaluationVisitor","buildNamedEvaluationVisitor","path","isClassExpression","node","body","el","isStaticBlock","isClassProperty","isClassPrivateProperty","static","classPath","state","nameNode","stringLiteral","get","unshiftContainer","staticBlock","statement","ast","addHelper","classAccessorProperty","ClassAccessorProperty","namedEvaluationVisitor","visitors","explode","maybeSequenceExpression","expressions","sequenceExpression","blocksToExpressions","blocks","map","block","isExpressionStatement","inheritsComments","expression","prependToInitializer","prop","value","expr","unaryExpression","manipulateOptions","_","parser","plugins","push","pre","enableFeature","file","FEATURES","staticBlocks","visitor","ClassBody","classBody","parentPath","id","type","isStatement","_namedEvaluationVisit","enter","forEach","f","call","pendingStaticBlocks","lastStaticProp","remove","tmp","generateDeclaredUidIdentifier","arrowBody","needsCompletionValue","isExpression","thisExpression","blockStatement","returnStatement","init","privateNames","Set","isPrivate","add","staticBlockPrivateId","staticBlockRef","privateName","identifier","pushContainer","classPrivateProperty","staticBlockClosureCall","callExpression","cloneNode","replaceWith","parent","insertAfter","expressionStatement"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { NodePath, Scope, types as t } from \"@babel/core\";\n\nimport {\n  buildNamedEvaluationVisitor,\n  enableFeature,\n  FEATURES,\n} from \"@babel/helper-create-class-features-plugin\";\n\n/**\n * Generate a uid that is not in `denyList`\n *\n * @param {Scope} scope\n * @param {Set<string>} denyList a deny list that the generated uid should avoid\n * @returns\n */\nfunction generateUid(scope: Scope, denyList: Set<string>) {\n  const name = \"\";\n  let uid;\n  let i = 1;\n  do {\n    uid = `_${name}`;\n    if (i > 1) uid += i;\n    i++;\n  } while (denyList.has(uid));\n  return uid;\n}\n\nfunction mapLast<T>(arr: T[], fn: (value: T) => T): T[] {\n  if (arr.length === 0) return arr;\n  return [...arr.slice(0, -1), fn(arr[arr.length - 1])];\n}\n\nexport default declare(({ types: t, template, traverse, assertVersion }) => {\n  assertVersion(REQUIRED_VERSION(\"^7.12.0\"));\n\n  const rawNamedEvaluationVisitor = buildNamedEvaluationVisitor(\n    (path: NodePath) => {\n      if (!path.isClassExpression()) return false;\n      for (let i = path.node.body.body.length - 1; i >= 0; i--) {\n        const el = path.node.body.body[i];\n        if (t.isStaticBlock(el)) {\n          return true;\n        }\n        if (\n          (t.isClassProperty(el) || t.isClassPrivateProperty(el)) &&\n          el.static\n        ) {\n          break;\n        }\n      }\n      return false;\n    },\n    (classPath: NodePath<t.ClassExpression>, state, name) => {\n      const nameNode = typeof name === \"string\" ? t.stringLiteral(name) : name;\n\n      classPath.get(\"body\").unshiftContainer(\n        \"body\",\n        t.staticBlock([\n          template.statement.ast`\n            ${state.addHelper(\"setFunctionName\")}(this, ${nameNode});\n          `,\n        ]),\n      );\n    },\n  );\n\n  if (!process.env.BABEL_8_BREAKING && !t.classAccessorProperty) {\n    // For old versions of Babel 7, with no ClassAccessorProperty support.\n    delete rawNamedEvaluationVisitor.ClassAccessorProperty;\n  }\n\n  const namedEvaluationVisitor = traverse.visitors.explode(\n    rawNamedEvaluationVisitor,\n  );\n\n  const maybeSequenceExpression = (\n    expressions: t.Expression[],\n  ): t.Expression => {\n    if (expressions.length === 1) {\n      return expressions[0];\n    } else {\n      return t.sequenceExpression(expressions);\n    }\n  };\n\n  const blocksToExpressions = (blocks: Array<t.StaticBlock>) =>\n    blocks.map(block => {\n      const { body } = block;\n      if (body.length === 1 && t.isExpressionStatement(body[0])) {\n        // We special-case the single expression case to avoid the iife, since\n        // it's common.\n        return t.inheritsComments(\n          t.inheritsComments(body[0].expression, body[0]),\n          block,\n        );\n      }\n      return t.inheritsComments(\n        template.expression.ast`(() => { ${body} })()`,\n        block,\n      );\n    });\n\n  const prependToInitializer = (\n    prop: t.ClassProperty | t.ClassPrivateProperty,\n    expressions: t.Expression[],\n  ) => {\n    prop.value = prop.value\n      ? t.sequenceExpression([...expressions, prop.value])\n      : maybeSequenceExpression(\n          mapLast(expressions, expr => t.unaryExpression(\"void\", expr)),\n        );\n  };\n\n  return {\n    name: \"transform-class-static-block\",\n    manipulateOptions: process.env.BABEL_8_BREAKING\n      ? undefined\n      : (_, parser) => parser.plugins.push(\"classStaticBlock\"),\n\n    pre() {\n      // Enable this in @babel/helper-create-class-features-plugin, so that it\n      // can be handled by the private fields and methods transform.\n      enableFeature(this.file, FEATURES.staticBlocks, /* loose */ false);\n    },\n\n    visitor: {\n      // Run on ClassBody and not on class so that if @babel/helper-create-class-features-plugin\n      // is enabled it can generate optimized output without passing from the intermediate\n      // private fields representation.\n      ClassBody(classBody) {\n        const { scope } = classBody;\n\n        // If needed, add the name to the class\n        let parentPath: NodePath<t.Node> = classBody.parentPath;\n        if (parentPath.isClassExpression() && !parentPath.node.id) {\n          do ({ parentPath } = parentPath);\n          while (\n            parentPath &&\n            !namedEvaluationVisitor[parentPath.type] &&\n            !parentPath.isStatement()\n          );\n          if (parentPath) {\n            namedEvalu