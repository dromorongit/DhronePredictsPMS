{"version":3,"names":["_helperPluginUtils","require","_pluginTransformDestructuring","_core","isAnonymousFunctionDefinition","node","t","isArrowFunctionExpression","isFunctionExpression","isClassExpression","id","emitSetFunctionNameCall","state","expression","name","callExpression","addHelper","stringLiteral","_default","exports","default","declare","api","assertVersion","TOP_LEVEL_USING","Map","isUsingDeclaration","isVariableDeclaration","kind","has","transformUsingDeclarationsVisitor","ForOfStatement","path","left","declarations","tmpId","scope","generateUidIdentifierBasedOnNode","ensureBlock","unshiftForXStatementBody","variableDeclaration","variableDeclarator","cloneNode","BlockStatement|StaticBlock","ctx","needsAwait","body","generateUidIdentifier","isAwaitUsing","get","delete","decl","currentInit","init","memberExpression","identifier","isIdentifier","disposeCall","replacement","template","statement","ast","awaitExpression","inherits","parentPath","isFunction","isTryStatement","isCatchClause","replaceWith","blockStatement","isStaticBlock","transformUsingDeclarationsVisitorSkipFn","traverse","visitors","merge","Function","skip","manipulateOptions","_","p","plugins","push","visitor","Program","clear","sourceType","some","innerBlockBody","stmt","isFunctionDeclaration","isImportDeclaration","shouldRemove","isExportDefaultDeclaration","declaration","varId","isClassDeclaration","toExpression","isExpression","exportNamedDeclaration","exportSpecifier","isExportNamedDeclaration","Object","keys","getOuterBindingIdentifiers","map","isExportDeclaration","set","remove","pushContainer","async"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { unshiftForXStatementBody } from \"@babel/plugin-transform-destructuring\";\nimport { types as t, template, traverse } from \"@babel/core\";\nimport type { NodePath, Visitor, PluginPass } from \"@babel/core\";\n\nconst enum USING_KIND {\n  NORMAL,\n  AWAIT,\n}\n\n// https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition\nfunction isAnonymousFunctionDefinition(\n  node: t.Node,\n): node is\n  | t.ClassExpression\n  | t.ArrowFunctionExpression\n  | t.FunctionExpression {\n  return (\n    t.isArrowFunctionExpression(node) ||\n    ((t.isFunctionExpression(node) || t.isClassExpression(node)) && !node.id)\n  );\n}\n\nfunction emitSetFunctionNameCall(\n  state: PluginPass,\n  expression: t.Expression,\n  name: string,\n) {\n  return t.callExpression(state.addHelper(\"setFunctionName\"), [\n    expression,\n    t.stringLiteral(name),\n  ]);\n}\n\nexport default declare(api => {\n  // The first Babel 7 version with usingCtx helper support.\n  api.assertVersion(REQUIRED_VERSION(\"^7.23.9\"));\n\n  const TOP_LEVEL_USING = new Map<t.Node, USING_KIND>();\n\n  function isUsingDeclaration(node: t.Node): node is t.VariableDeclaration {\n    if (!t.isVariableDeclaration(node)) return false;\n    return (\n      node.kind === \"using\" ||\n      node.kind === \"await using\" ||\n      TOP_LEVEL_USING.has(node)\n    );\n  }\n\n  const transformUsingDeclarationsVisitor: Visitor<PluginPass> = {\n    ForOfStatement(path: NodePath<t.ForOfStatement>) {\n      const { left } = path.node;\n      if (!isUsingDeclaration(left)) return;\n\n      const { id } = left.declarations[0];\n      const tmpId = path.scope.generateUidIdentifierBasedOnNode(id);\n      left.declarations[0].id = tmpId;\n      left.kind = \"const\";\n\n      path.ensureBlock();\n      unshiftForXStatementBody(path, [\n        t.variableDeclaration(\"using\", [\n          t.variableDeclarator(id, t.cloneNode(tmpId)),\n        ]),\n      ]);\n    },\n    \"BlockStatement|StaticBlock\"(\n      path: NodePath<t.BlockStatement | t.StaticBlock>,\n      state,\n    ) {\n      let ctx: t.Identifier | null = null;\n      let needsAwait = false;\n      const scope = path.scope;\n\n      for (const node of path.node.body) {\n        if (!isUsingDeclaration(node)) continue;\n        ctx ??= scope.generateUidIdentifier(\"usingCtx\");\n        const isAwaitUsing =\n          node.kind === \"await using\" ||\n          TOP_LEVEL_USING.get(node) === USING_KIND.AWAIT;\n        needsAwait ||= isAwaitUsing;\n\n        if (!TOP_LEVEL_USING.delete(node)) {\n          node.kind = \"const\";\n        }\n        for (const decl of node.declarations) {\n          const currentInit = decl.init;\n          decl.init = t.callExpression(\n            t.memberExpression(\n              t.cloneNode(ctx),\n              isAwaitUsing ? t.identifier(\"a\") : t.identifier(\"u\"),\n            ),\n            [\n              isAnonymousFunctionDefinition(currentInit) &&\n              t.isIdentifier(decl.id)\n                ? emitSetFunctionNameCall(state, currentInit, decl.id.name)\n                : currentInit,\n            ],\n          );\n        }\n      }\n      if (!ctx) return;\n\n      const disposeCall = t.callExpression(\n        t.memberExpression(t.cloneNode(ctx), t.identifier(\"d\")),\n        [],\n      );\n\n      const replacement = template.statement.ast`\n        try {\n          var ${t.cloneNode(