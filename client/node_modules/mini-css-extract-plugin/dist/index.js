"use strict";

const path = require("path");
const {
  validate
} = require("schema-utils");
const {
  SyncWaterfallHook
} = require("tapable");
const schema = require("./plugin-options.json");
const {
  ABSOLUTE_PUBLIC_PATH,
  AUTO_PUBLIC_PATH,
  BASE_URI,
  MODULE_TYPE,
  SINGLE_DOT_PATH_SEGMENT,
  compareModulesByIdentifier,
  compileBooleanMatcher,
  getUndoPath,
  trueFn
} = require("./utils");

/** @typedef {import("schema-utils/declarations/validate").Schema} Schema */
/** @typedef {import("webpack").Compiler} Compiler */
/** @typedef {import("webpack").Compilation} Compilation */
/** @typedef {import("webpack").ChunkGraph} ChunkGraph */
/** @typedef {import("webpack").Chunk} Chunk */
/** @typedef {import("webpack").ChunkGroup} ChunkGroup */
/** @typedef {import("webpack").Module} Module */
/** @typedef {import("webpack").Dependency} Dependency */
/** @typedef {import("webpack").sources.Source} Source */
/** @typedef {import("webpack").Configuration} Configuration */
/** @typedef {import("webpack").WebpackError} WebpackError */
/** @typedef {import("webpack").AssetInfo} AssetInfo */
/** @typedef {import("./loader.js").Dependency} LoaderDependency */

/** @typedef {NonNullable<Required<Configuration>['output']['filename']>} Filename */
/** @typedef {NonNullable<Required<Configuration>['output']['chunkFilename']>} ChunkFilename */

/**
 * @typedef {object} LoaderOptions
 * @property {string | ((resourcePath: string, rootContext: string) => string)=} publicPath public path
 * @property {boolean=} emit true when need to emit, otherwise false
 * @property {boolean=} esModule need to generate ES module syntax
 * @property {string=} layer a layer
 * @property {boolean=} defaultExport true when need to use default export, otherwise false
 */

/**
 * @typedef {object} PluginOptions
 * @property {Filename=} filename filename
 * @property {ChunkFilename=} chunkFilename chunk filename
 * @property {boolean=} ignoreOrder true when need to ignore order, otherwise false
 * @property {string | ((linkTag: HTMLLinkElement) => void)=} insert link insert place or a custom insert function
 * @property {Record<string, string>=} attributes link attributes
 * @property {string | false | 'text/css'=} linkType value of a link type attribute
 * @property {boolean=} runtime true when need to generate runtime code, otherwise false
 * @property {boolean=} experimentalUseImportModule true when need to use `experimentalUseImportModule` API, otherwise false
 */

/**
 * @typedef {object} NormalizedPluginOptions
 * @property {Filename} filename filename
 * @property {ChunkFilename=} chunkFilename chunk filename
 * @property {boolean} ignoreOrder true when need to ignore order, otherwise false
 * @property {string | ((linkTag: HTMLLinkElement) => void)=} insert a link insert place or a custom insert function
 * @property {Record<string, string>=} attributes link attributes
 * @property {string | false | 'text/css'=} linkType value of a link type attribute
 * @property {boolean} runtime true when need to generate runtime code, otherwise false
 * @property {boolean=} experimentalUseImportModule true when need to use `experimentalUseImportModule` API, otherwise false
 */

/**
 * @typedef {object} RuntimeOptions
 * @property {string | ((linkTag: HTMLLinkElement) => void)=} insert a link insert place or a custom insert function
 * @property {string | false | 'text/css'} linkType value of a link type attribute
 * @property {Record<string, string>=} attributes link attributes
 */

const pluginName = "mini-css-extract-plugin";
const pluginSymbol = Symbol(pluginName);
const DEFAULT_FILENAME = "[name].css";
/**
 * @type {Set<string>}
 */
const TYPES = new Set([MODULE_TYPE]);
/**
 * @type {ReturnType<Module["codeGeneration"]>}
 */
const CODE_GENERATION_RESULT = {
  sources: new Map(),
  runtimeRequirements: new Set()
};

// eslint-disable-next-line jsdoc/no-restricted-syntax
/** @typedef {{ context: string | null, identifier: string, identifierIndex: number, content: Buffer, sourceMap?: Buffer, media?: string, supports?: string, layer?: any, assetsInfo?: Map<string, AssetInfo>, assets?: { [key: string]: Source }}} CssModuleDependency */
/** @typedef {Module & { content: Buffer, media?: string, sourceMap?: Buffer, supports?: string, layer?: string, assets?: { [key: string]: Source }, assetsInfo?: Map<string, AssetInfo> }} CssModule */
/** @typedef {{ new(dependency: CssModuleDependency): CssModule }} CssModuleConstructor */
/** @typedef {Dependency & CssModuleDependency} CssDependency */
/** @typedef {Omit<LoaderDependency, "context">} CssDependencyOptions */
/** @typedef {{ new(loaderDependency: CssDependencyOptions, context: string | null, identifierIndex: number): CssDependency }} CssDependencyConstructor */

/**
 * @typedef {object} VarNames
 * @property {string} tag tag
 * @property {string} chunkId chunk id
 * @property {string} href href
 * @property {string} resolve resolve
 * @property {string} reject reject
 */

/**
 * @typedef {object} MiniCssExtractPluginCompilationHooks
 * @property {import("tapable").SyncWaterfallHook<[string, VarNames], string>} beforeTagInsert before tag insert hook
 * @property {SyncWaterfallHook<[string, Chunk]>} linkPreload link preload hook
 * @property {SyncWaterfallHook<[string, Chunk]>} linkPrefetch link prefetch hook
 */

/**
 * @type {WeakMap<Compiler["webpack"], CssModuleConstructor>}
 */
const cssModuleCache = new WeakMap();
/**
 * @type {WeakMap<Compiler["webpack"], CssDependencyConstructor>}
 */
const cssDependencyCache = new WeakMap();
/**
 * @type {WeakSet<Compiler["webpack"]>}
 */
const registered = new WeakSet();

/** @type {WeakMap<Compilation, MiniCssExtractPluginCompilationHooks>} */
const compilationHooksMap = new WeakMap();
class MiniCssExtractPlugin {
  /**
   * @param {Compiler["webpack"]} webpack webpack
   * @returns {CssModuleConstructor} CSS module constructor
   */
  static getCssModule(webpack) {
    /**
     * Prevent creation of multiple CssModule classes to allow other integrations to get the current CssModule.
     */
    if (cssModuleCache.has(webpack)) {
      return /** @type {CssModuleConstructor} */cssModuleCache.get(webpack);
    }
    class CssModule extends webpack.Module {
      /**
       * @param {CssModuleDependency} dependency css module dependency
       */
      constructor({
        context,
        identifier,
        identifierIndex,
        content,
        layer,
        supports,
        media,
        sourceMap,
        assets,
        assetsInfo
      }) {
        super(MODULE_TYPE, /** @type {string | undefined} */context);
        this.id = "";
        this._context = context;
        this._identifier = identifier;
        this._identifierIndex = identifierIndex;
        this.content = content;
        this.layer = layer;
        this.supports = supports;
        this.media = media;
        this.sourceMap = sourceMap;
        this.assets = assets;
        this.assetsInfo = assetsInfo;
        this._needBuild = true;
      }

      // no source() so webpack 4 doesn't do add stuff to the bundle

      size() {
        return this.content.length;
      }
      identifier() {
        return `css|${this._identifier}|${this._identifierIndex}|${this.layer || ""}|${this.supports || ""}|${this.media}}}`;
      }

      /**
       * @param {Parameters<Module["readableIdentifier"]>[0]} requestShortener request shortener
       * @returns {ReturnType<Module["readableIdentifier"]>} readable identifier
       */
      readableIdentifier(requestShortener) {
        return `css ${requestShortener.shorten(this._identifier)}${this._identifierIndex ? ` (${this._identifierIndex})` : ""}${this.layer ? ` (layer ${this.layer})` : ""}${this.supports ? ` (supports ${this.supports})` : ""}${this.media ? ` (media ${this.media})` : ""}`;
      }
      getSourceTypes() {
        return TYPES;
      }
      codeGeneration() {
        return CODE_GENERATION_RESULT;
      }
      nameForCondition() {
        const resource = /** @type {string} */
        this._identifier.split("!").pop();
        const idx = resource.indexOf("?");
        if (idx >= 0) {
          return resource.slice(0, Math.max(0, idx));
        }
        return resource;
      }

      /**
       * @param {Module} module a module
       */
      updateCacheModule(module) {
        if (!this.content.equals(/** @type {CssModule} */module.content) || this.layer !== /** @type {CssModule} */module.layer || this.supports !== /** @type {CssModule} */module.supports || this.media !== /** @type {CssModule} */module.media || (this.sourceMap ? !this.sourceMap.equals(/** @type {Uint8Array} * */
        /** @type {CssModule} */module.sourceMap) : false) || this.assets !== /** @type {CssModule} */module.assets || this.assetsInfo !== /** @type {CssModule} */module.assetsInfo) {
          this._needBuild = true;
          this.content = /** @type {CssModule} */module.content;
          this.layer = /** @type {CssModule} */module.layer;
          this.supports = /** @type {CssModule} */module.supports;
          this.media = /** @type {CssModule} */module.media;
          this.sourceMap = /** @type {CssModule} */module.sourceMap;
          this.assets = /** @type {CssModule} */module.assets;
          this.assetsInfo = /** @type {CssModule} */module.assetsInfo;
        }
      }
      needRebuild() {
        return this._needBuild;
      }

      /**
       * @param {Parameters<Module["needBuild"]>[0]} context context info
       * @param {Parameters<Module["needBuild"]>[1]} callback callback function, returns true, if the module needs a rebuild
       */
      needBuild(context, callback) {
        callback(undefined, this._needBuild);
      }

      /**
       * @param {Parameters<Module["build"]>[0]} options options
       * @param {Parameters<Module["build"]>[1]} compilation compilation
       * @param {Parameters<Module["build"]>[2]} resolver resolver
       * @param {Parameters<Module["build"]>[3]} fileSystem file system
       * @param {Parameters<Module["build"]>[4]} callback callback
       */
      build(options, compilation, resolver, fileSystem, callback) {
        this.buildInfo = {
          assets: this.assets,
          assetsInfo: this.assetsInfo,
          cacheable: true,
          hash: (/** @type {string} */

          this._computeHash(/** @type {string} */
          compilation.outputOptions.hashFunction))
        };
        this.buildMeta = {};
        this._needBuild = false;
        callback();
      }

      /**
       * @private
       * @param {string} hashFunction hash function
       * @returns {string | Buffer} hash digest
       */
      _computeHash(hashFunction) {
        const hash = webpack.util.createHash(hashFunction);
        hash.update(this.content);
        if (this.layer) {
          hash.update(this.layer);
        }
        hash.update(this.supports || "");
        hash.update(this.media || "");
        hash.update(this.sourceMap || "");
        return hash.digest("hex");
      }

      /**
       * @param {Parameters<Module["updateHash"]>[0]} hash hash
       * @param {Parameters<Module["updateHash"]>[1]} context context
       */
      updateHash(hash, context) {
        super.updateHash(hash, context);
        hash.update(/** @type {string} */
        /** @type {NonNullable<Module["buildInfo"]>} */
        this.buildInfo.hash);
      }

      /**
       * @param {Parameters<Module["serialize"]>[0]} context serializer context
       */
      serialize(context) {
        const {
          write
        } = context;
        write(this._context);
        write(this._identifier);
        write(this._identifierIndex);
        write(this.content);
        write(this.layer);
        write(this.supports);
        write(this.media);
        write(this.sourceMap);
        write(this.assets);
        write(this.assetsInfo);
        write(this._needBuild);
        super.serialize(context);
      }

      /**
       * @param {Parameters<Module["deserialize"]>[0]} context deserializer context
       */
      deserialize(context) {
        this._needBuild = context.read();
        super.deserialize(context);
      }
    }
    cssModuleCache.set(webpack, CssModule);
    webpack.util.serialization.register(CssModule, path.resolve(__dirname, "CssModule"), null, {
      serialize(instance, context) {
        instance.serialize(context);
      },
      deserialize(context) {
        const {
          read
        } = context;
        const contextModule = read();
        const identifier = read();
        const identifierIndex = read();
        const content = read();
        const layer = read();
        const supports = read();
        const media = read();
        const sourceMap = read();
        const assets = read();
        const assetsInfo = read();
        const dep = new CssModule({
          context: contextModule,
          identifier,
          identifierIndex,
          content,
          layer,
          supports,
          media,
          sourceMap,
          assets,
          assetsInfo
        });
        dep.deserialize(context);
        return dep;
      }
    });
    return CssModule;
  }

  /**
   * @param {Compiler["webpack"]} webpack webpack
   * @returns {CssDependencyConstructor} CSS dependency constructor
   */
  static getCssDependency(webpack) {
    /**
     * Prevent creation of multiple CssDependency classes to allow other integrations to get the current CssDependency.
     */
    if (cssDependencyCache.has(webpack)) {
      return /** @type {CssDependencyConstructor} */cssDependencyCache.get(webpack);
    }
    class CssDependency extends webpack.Dependency {
      /**
       * @param {CssDependencyOptions} loaderDependency loader dependency
       * @param {string | null} context context
       * @param {number} identifierIndex identifier index
       */
      constructor({
        identifier,
        content,
        layer,
        supports,
        media,
        sourceMap
      }, context, identifierIndex) {
        super();
        this.identifier = identifier;
        this.identifierIndex = identifierIndex;
        this.content = content;
        this.layer = layer;
        this.supports = supports;
        this.media = media;
        this.sourceMap = sourceMap;
        this.context = context;
        /** @type {{ [key: string]: Source } | undefined}} */
        this.assets = undefined;
        /** @type {Map<string, AssetInfo> | undefined} */
        this.assetsInfo = undefined;
      }

      /**
       * @returns {ReturnType<Dependency["getResourceIdentifier"]>} a resource identifier
       */
      getResourceIdentifier() {
        return `css-module-${this.identifier}-${this.identifierIndex}`;
      }

      /**
       * @returns {ReturnType<Dependency["getModuleEvaluationSideEffectsState"]>} side effect state
       */
      getModuleEvaluationSideEffectsState() {
        return webpack.ModuleGraphConnection.TRANSITIVE_ONLY;
      }

      /**
       * @param {Parameters<Dependency["serialize"]>[0]} context serializer context
       */
      serialize(context) {
        const {
          write
        } = context;
        write(this.identifier);
        write(this.content);
        write(this.layer);
        write(this.supports);
        write(this.media);
        write(this.sourceMap);
        write(this.context);
        write(this.identifierIndex);
        write(this.assets);
        write(this.assetsInfo);
        super.serialize(context);
      }

      /**
       * @param {Parameters<Dependency["deserialize"]>[0]} context deserializer context
       */
      deserialize(context) {
        super.deserialize(context);
      }
    }
    cssDependencyCache.set(webpack, CssDependency);
    webpack.util.serialization.register(CssDependency, path.resolve(__dirname, "CssDependency"), null, {
      serialize(instance, context) {
        instance.serialize(context);
      },
      deserialize(context) {
        const {
          read
        } = context;
        const dep = new CssDependency({
          identifier: read(),
          content: read(),
          layer: read(),
          supports: read(),
          media: read(),
          sourceMap: read()
        }, read(), read());
        const assets = read();
        const assetsInfo = read();
        dep.assets = assets;
        dep.assetsInfo = assetsInfo;
        dep.deserialize(context);
        return dep;
      }
    });
    return CssDependency;
  }

  /**
   * Returns all hooks for the given compilation
   * @param {Compilation} compilation the compilation
   * @returns {MiniCssExtractPluginCompilationHooks} hooks
   */
  static getCompilationHooks(compilation) {
    let hooks = compilationHooksMap.get(compilation);
    if (!hooks) {
      hooks = {
        beforeTagInsert: new SyncWaterfallHook(["source", "varNames"], "string"),
        linkPreload: new SyncWaterfallHook(["source", "chunk"]),
        linkPrefetch: new SyncWaterfallHook(["source", "chunk"])
      };
      compilationHooksMap.set(compilation, hooks);
    }
    return hooks;
  }

  /**
   * @param {PluginOptions=} options options
   */
  constructor(options = {}) {
    validate(/** @type {Schema} */schema, options, {
      baseDataPath: "options"
    });

    /**
     * @private
     * @type {WeakMap<Chunk, Set<CssModule>>}
     */
    this._sortedModulesCache = new WeakMap();

    /**
     * @private
     * @type {NormalizedPluginOptions}
     */
    this.options = {
      filename: DEFAULT_FILENAME,
      ignoreOrder: false,
      // TODO remove in the next major release
      experimentalUseImportModule: undefined,
      runtime: true,
      ...options
    };

    /**
     * @private
     * @type {RuntimeOptions}
     */
    this.runtimeOptions = {
      insert: options.insert,
      linkType:
      // Todo in next major release set default to "false"
      typeof options.linkType === "boolean" && /** @type {boolean} */options.linkType === true || typeof options.linkType === "undefined" ? "text/css" : options.linkType,
      attributes: options.attributes
    };
    if (!this.options.chunkFilename) {
      const {
        filename
      } = this.options;
      if (typeof filename !== "function") {
        const hasName = /** @type {string} */filename.includes("[name]");
        const hasId = /** @type {string} */filename.includes("[id]");
        const hasChunkHash = /** @type {string} */
        filename.includes("[chunkhash]");
        const hasContentHash = /** @type {string} */
        filename.includes("[contenthash]");

        // Anything changing depending on chunk is fine
        if (hasChunkHash || hasContentHash || hasName || hasId) {
          this.options.chunkFilename = filename;
        } else {
          // Otherwise prefix "[id]." in front of the basename to make it changing
          this.options.chunkFilename = /** @type {string} */
          filename.replace(/(^|\/)([^/]*(?:\?|$))/, "$1[id].$2");
        }
      } else {
        this.options.chunkFilename = "[id].css";
      }
    }
  }

  /**
   * @param {Compiler} compiler compiler
   */
  apply(compiler) {
    const {
      webpack
    } = compiler;
    if (this.options.experimentalUseImportModule && typeof (/** @type {Compiler["options"]["experiments"] & { executeModule?: boolean }} */
    compiler.options.experiments.executeModule) === "undefined") {
      /** @type {Compiler["options"]["experiments"] & { executeModule?: boolean }} */

      // @ts-expect-error TODO remove in the next major release
      compiler.options.experiments.executeModule = true;
    }

    // TODO bug in webpack, remove it after it will be fixed
    // webpack tries to `require` loader firstly when serializer doesn't found
    if (!registered.has(webpack)) {
      registered.add(webpack);
      webpack.util.serialization.registerLoader(/^mini-css-extract-plugin\//, trueFn);
    }
    const {
      splitChunks
    } = compiler.options.optimization;
    if (splitChunks && /** @type {string[]} */splitChunks.defaultSizeTypes.includes("...")) {
      /** @type {string[]} */
      splitChunks.defaultSizeTypes.push(MODULE_TYPE);
    }
    const CssModule = MiniCssExtractPlugin.getCssModule(webpack);
    const CssDependency = MiniCssExtractPlugin.getCssDependency(webpack);
    const {
      NormalModule
    } = compiler.webpack;
    compiler.hooks.compilation.tap(pluginName, compilation => {
      const {
        loader: normalModuleHook
      } = NormalModule.getCompilationHooks(compilation);
      normalModuleHook.tap(pluginName,
      /**
       * @param {object} loaderContext loader context
       */
      loaderContext => {
        /** @type {object & { [pluginSymbol]: { experimentalUseImportModule: boolean | undefined } }} */
        loaderContext[pluginSymbol] = {
          experimentalUseImportModule: this.options.experimentalUseImportModule
        };
      });
    });
    compiler.hooks.thisCompilation.tap(pluginName, compilation => {
      class CssModuleFactory {
        /**
         * @param {{ dependencies: Dependency[] }} dependencies
         * @param {(err?: null | Error, result?: CssModule) => void} callback
         */

        create({
          dependencies: [dependency]
        }, callback) {
          callback(undefined, new CssModule(/** @type {CssDependency} */dependency));
        }
      }
      compilation.dependencyFactories.set(CssDependency,
      // @ts-expect-error TODO fix in the next major release and fix using `CssModuleFactory extends webpack.ModuleFactory`
      new CssModuleFactory());
      class CssDependencyTemplate {
        apply() {}
      }
      compilation.dependencyTemplates.set(CssDependency, new CssDependencyTemplate());
      compilation.hooks.renderManifest.tap(pluginName,
      /**
       * @param {ReturnType<Compilation["getRenderManifest"]>} result result
       * @param {Parameters<Compilation["getRenderManifest"]>[0]} chunk chunk
       * @returns {ReturnType<Compilation["getRenderManifest"]>} a rendered manifest
       */
      (result, {
        chunk
      }) => {
        const {
          chunkGraph
        } = compilation;
        const {
          HotUpdateChunk
        } = webpack;

        // We don't need hot update chunks for css
        // We will use the real asset instead to update
        if (chunk instanceof HotUpdateChunk) {
          return result;
        }
        const renderedModules = /** @type {CssModule[]} */

        [...this.getChunkModules(chunk, chunkGraph)].filter(module => module.type === MODULE_TYPE);
        const filenameTemplate = /** @type {string} */

        chunk.canBeInitial() ? this.options.filename : this.options.chunkFilename;
        if (renderedModules.length > 0) {
          result.push({
            render: () => this.renderContentAsset(compiler, compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener, filenameTemplate, {
              contentHashType: MODULE_TYPE,
              chunk
            }),
            filenameTemplate,
            pathOptions: {
              chunk,
              contentHashType: MODULE_TYPE
            },
            identifier: `${pluginName}.${chunk.id}`,
            hash: chunk.contentHash[MODULE_TYPE]
          });
        }
        return result;
      });
      compilation.hooks.contentHash.tap(pluginName, chunk => {
        const {
          outputOptions,
          chunkGraph
        } = compilation;
        const modules = this.sortModules(compilation, chunk, /** @type {CssModule[]} */
        chunkGraph.getChunkModulesI